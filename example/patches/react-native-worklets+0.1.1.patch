diff --git a/node_modules/react-native-worklets/cpp/wrappers/JsiArrayWrapper.h b/node_modules/react-native-worklets/cpp/wrappers/JsiArrayWrapper.h
index 32eda78..0bdf113 100644
--- a/node_modules/react-native-worklets/cpp/wrappers/JsiArrayWrapper.h
+++ b/node_modules/react-native-worklets/cpp/wrappers/JsiArrayWrapper.h
@@ -388,8 +388,10 @@ public:
         std::all_of(nameStr.begin(), nameStr.end(), ::isdigit)) {
       // Return property by index
       auto index = std::stoi(nameStr.c_str());
-      auto prop = _array[index];
-      return JsiWrapper::unwrap(runtime, prop);
+      if (index >= 0 && index < _array.size()) {
+        auto prop = _array[index];
+        return JsiWrapper::unwrap(runtime, prop);
+      }
     }
     // Return super JsiHostObject's get
     return JsiHostObject::get(runtime, name);
diff --git a/node_modules/react-native-worklets/cpp/wrappers/JsiObjectWrapper.h b/node_modules/react-native-worklets/cpp/wrappers/JsiObjectWrapper.h
index ea66507..acc2dda 100644
--- a/node_modules/react-native-worklets/cpp/wrappers/JsiObjectWrapper.h
+++ b/node_modules/react-native-worklets/cpp/wrappers/JsiObjectWrapper.h
@@ -209,12 +209,15 @@ private:
       _hostFunction = std::make_shared<jsi::HostFunctionType>(
           func.getHostFunction(runtime));
     } else {
-
-      throw jsi::JSError(
-          runtime,
-          "Regular javascript functions cannot be shared. Try "
-          "decorating the function with the 'worklet' keyword to allow "
-          "the javascript function to be used as a worklet.");
+      setType(JsiWrapperType::HostFunction);
+      _hostFunction =
+           std::make_shared<jsi::HostFunctionType>(JSI_HOST_FUNCTION_LAMBDA {
+             throw jsi::JSError(
+                 runtime,
+                 "Regular javascript functions cannot be shared. Try "
+                 "decorating the function with the 'worklet' keyword to allow "
+                 "the javascript function to be used as a worklet.");
+           });
     }
   }
 
diff --git a/node_modules/react-native-worklets/src/plugin/index.js b/node_modules/react-native-worklets/src/plugin/index.js
index ef077df..7eefcf0 100644
--- a/node_modules/react-native-worklets/src/plugin/index.js
+++ b/node_modules/react-native-worklets/src/plugin/index.js
@@ -5,6 +5,16 @@ const { transformSync } = require("@babel/core");
 const traverse = require("@babel/traverse").default;
 const parse = require("@babel/parser").parse;
 
+const globals = new Set([
+  '_chronoNow',
+  '_log',
+  'HermesInternal',
+]);
+
+const functionArgsToWorkletize = new Map([
+  ['useTemplateValue', [0]],
+]);
+
 function buildWorkletString(t, fun, closureVariables, name, state) {
   fun.traverse({
     enter(path) {
@@ -71,11 +81,17 @@ function processWorkletFunction(t, fun, state) {
   traverse(astWorkletCopy, {
     ReferencedIdentifier(path) {
       const name = path.node.name;
+
+      if (globals.has(name)) {
+        return;
+      }
+
       const parentNode = path.parent;
 
       if (
         parentNode.type === "MemberExpression" &&
-        parentNode.object !== path.node
+        parentNode.object !== path.node &&
+        !parentNode.computed
       ) {
         return;
       }
@@ -256,9 +272,28 @@ function processIfWorkletNode(t, p, state) {
   });
 }
 
+function processWorklets(t, path, state) {
+  const name =
+    path.node.callee.type === 'MemberExpression'
+      ? path.node.callee.property.name
+      : path.node.callee.name;
+
+  const indexes = functionArgsToWorkletize.get(name);
+  if (Array.isArray(indexes)) {
+    indexes.forEach((index) => {
+      processWorkletFunction(t, path.get(`arguments.${index}`), state);
+    });
+  }
+}
+
 module.exports = function ({ types: t }) {
   return {
     visitor: {
+      CallExpression: {
+        exit(path, state) {
+          processWorklets(t, path, state);
+        },
+      },
       "FunctionDeclaration|FunctionExpression|ArrowFunctionExpression": {
         exit(path, state) {
           processIfWorkletNode(t, path, state);
